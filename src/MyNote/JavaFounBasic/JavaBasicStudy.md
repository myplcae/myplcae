异或运算------------    ^
![img.png](img.png)
代码示例
![img_1.png](img_1.png)
转二进制方法：Integer.toBinaryString

== 和 equals 的区别是什么：
    对于基本类型，==是比较的值，对于引用类型，==比较的是地址；
    如果没有重写equals，则此时equals相当于==；如果重写了equals,则其比较的是内容。
final的作用：
    修饰成员变量，表示不可再做更改，其修饰的子类不可以被继承；
    final类中的方法默认是final的；private类型的方法默认是final的；
线程的创建方式：
    1.继承Thread类重写run方法；
    2、实现Runable接口；（原则上这个方式是第一个方法的变种）；!![img_3.png](img_3.png)
    3、实现Callable接口；
    4、可以通过创建线程池创建
线程间通信方式：
    1、使用 volatile 关键字（共享内存思想）：大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感
知并执行相应的业务。这也是最简单的一种实现方式
    2、方式二：使用Object类的wait()、notify()、notifyaAl() 方法：它们是多线程通信的基础，而这种实现方式的思想自然是
线程间通信，三则必须配合synchronized使用，wait是释放锁，其他二者是不释放锁；
    wait(long) 方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒，
    notify() 方法作用是随机通知一个当前对象锁的阻塞队列中的线程（即调用过wait方法的线程），
    notifyAll() 方法作用是唤醒当前对象锁阻塞队列中的所有线程(即调用过wait方法的线程）；
    3、join()
run()和start()有什么区别:
    start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。
线程的生命周期：
    1、新建，是刚使用new方法，new出来的线程；
    2、就绪，是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段；
    3、运行，当就绪的线程被调度并获得CPU资源时，便进入运行状态；
    4、阻塞，在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态；
    5、销毁，线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁。
悲观锁和乐观锁：
    1、悲观锁（synchronized、ReentrantLock）：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享
数据被修改)， 所以 每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资
源每次只给一个线程 使用，其它线程阻塞，用完后再把资源转让给其它线程。高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导
致系统的上下文切换，增加系统的性能开销。 并且，悲观锁还可能会存在死锁问题，影响代码的正常运行
    2、乐观锁（AtomicInteger、LongAdder、CAS算法）：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线
程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了，高并发的场景下，乐观
锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），
会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。
    悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐
观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。
    乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量
创建线程池的几个核心构造参数:![img_2.png](img_2.png)

synchronized 和 ReentrantLock 有什么区别 :
    synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，
那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，synchronized 早期的实现比较低效，对
比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。
    相同点：两者都是可重入锁
    ![img_4.png](img_4.png)

ThreadLocal：![img_5.png](img_5.png)

sleep和wait有什么区别：
    二者都是用来休眠线程的方法且都能响应interrupt的中断；
    不同：wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出；而 sleep 可以单独使用，无需配合 synchronized 
一起使用。wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法，sleep 方法具有主动唤醒功能，而不传递任何参数的 
wait 方法只能被动的被唤醒，wait 方法会主动的释放锁，而 sleep 方法则不会，调用 sleep 方法线程会进入 TIMED_WAITING 有时限
等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态。



   