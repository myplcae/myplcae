bean的生命周期：
        1、实例化 Instantiation：当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一尚未初始化的依赖时，
    容器会调用createBean进行实例化；
        2、设置对象属性（依赖注入）：实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition中的信息以及通过
    BeanWrapper提供的设置属性的接口完成属性设置与依赖注入；
        3、处理Aware接口：拿到被封装对象之后就可以通过aware接口调用然后被使用；
        4、使用完之后就会被回收。
    ![img.png](img.png)
Spring AOP:
    springAOP是spring的一个核心设计理念，及面向切面编程；由于有了bean的理念，就有了中间层代理实现对象托管的模式，而需要额外处理的
部分就变成了由中间层代理的模式，即切面编程模式。
Spring IOC和DI:
    IOC:这部分功能相当于所有 Spring 框架运行的基础，以前我们操作对象都需要手动的 new 对象，由对象的作用域决定对象的生命周期。
使用 Spring 后，由框架提供了统一的容器来实例化、管理这些对象，并自动组织对象与对象间的关系。这种容器称为 IoC 容器，
有些地方也叫 Spring Bean 容器、Spring 容器。对象之间的复杂关系（体现在代码中就是对象中成员变量，引用了另一个对象），
也交给了容器来进行设置。它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的
“控制反转” 概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。
    DI:相对于IoC而言，依赖注入更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection）就是由IOC容器
在运行期间，动态地将某种依赖关系注入到对象之中，即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某
种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。
    DI的基本原则：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应
该从应用组件的代码中 抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的
setter）或者是构造器传递给需要的对象。
@Autowaire和@Resource的区别：
    @Autowired 是 Spring 定义的注解，@Resource 是 Java 定义的注解；
    查找顺序刚好相反：前者先根据类型，后者先根据名称。
依赖注入的方式：
    1.属性注入（Field Injection）
    2.构造器注入（Constructor Injection） 
    3.setter 方法注入;



    
    