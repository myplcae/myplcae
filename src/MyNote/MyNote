1.原子性：对基本数据类型的变量读取和赋值是保证了原子性的，要么都成功，要么都失败，这些操作不可被中断
i = 10;
catche 10,memory 10

a = 10;  原子性
b = a;    不满足； 会先创建一个b然后再去赋值给a；
c++; 不满足
c=c+1; 不满足

2、可见性
通过volation关键字保证；但是不会保证原子性
3、有序性
happens-before relationship
    3.1代码的执行顺序，编写在前面的发生在编写在后面的；
    3.2unlock必须发生在lock之后；
    3.3vliatile修饰的变量，对一个变量的写操作先于对该变量的读操作；
    3.4传递规则，操作A先于B，B先于C，那么A肯定先于C
    3.5线程启动规则，start方法肯定先于线程run
    3.6线程的中断规则，interrupt这个动作必须发生在捕获该动作之前；
    3.7对象销毁规则，初始化必须发生在finalize之前
    3.8线程终结规则，所有的操作都发生在线程死亡之前


volatile关键字
    一旦一个贡献变量被volatile修饰，则具备两层语义
    1、保证了不同线程间的可见性；
    2、禁止对其进行重排序，也就是保证了有序性；
    3、并未保证原子性；
    4、保证重排序的时候不会把前面的指令放到屏障的前面，也不会把前面的放到后面
    5、强制对缓存的修改操作会立刻写入主存
    6、如果是写操作，会导致其他CPU中的缓存失效
volatile使用场景：
    1、状态标记
    valatile boolean start = trur;
    while(true){
        //
        }
    void close(){
        start  = false;
    }
    2、屏障前后的一致性
    volatile boolean init;

    -------Thread1--------
    obj = createObj();
    init = true;
    -------Thread2--------
    while(!init){
        sleep();
    }
    useTheobj(obj);
    ----------------------
1、CPU的结构；
2、JMM的大致结构；
3、缓存一致性协议；
4、指令重排序；
5、happens-before规则
6、并发编程三大要素
7、volatile作用

-----------------------------
由多个线程同时运行结果错误引申的笔记：
-----------------------------
读写锁分离；RWL
不可变对象设计模式：
    不可变对象一定是线程安全的
    可变对象不一定是线程不安全的-->stringbuffer(原因是被加了很多锁)
                             stringbuild(没被加锁所以不安全但是性能快)